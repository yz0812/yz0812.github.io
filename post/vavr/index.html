<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
<title>VAVR 快速指南 - yz</title>
<meta name="description" content="少年拥有了时间,时间带走了年少" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

<link type="text/css" rel="stylesheet" href="https://yz0812.github.io/styles/main.css" media="screen" />
<link type="text/css" rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" />
<link type="text/css" rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" />
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css" integrity="sha512-FwY1WVsm4UQgrOXt6kaQ53w83cOHa8fSvjFn/BvVOCYVPmkSR39k/xnU+8hht3zW6JL1TBd4C/aVQIAV58Cg6A==" crossorigin="anonymous" /> -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/atom-one-dark.min.css" integrity="sha512-Jlyabam8ztU2kOGN19fSzv1Go9nt9A43UA6vhmL1MPsQMeoPZd+p7pbmegAtyl8kulna0Cqwb7Pgj4adGTLCXA==" crossorigin="anonymous" />
<script type="text/javascript" src="https://yz0812.github.io/media/scripts/jquery.js"></script>
<!-- <script type="text/javascript" src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js" integrity="sha512-tHQeqtcNWlZtEh8As/4MmZ5qpy0wj04svWFK7MIzLmUVIzaHXS8eod9OmHxyBL1UET5Rchvw7Ih4ZDv5JojZww==" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-7JNCPNX91Z"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'G-7JNCPNX91Z');
</script>


<script>
  hljs.initHighlightingOnLoad();
</script>

</head>

<body>
  <div class="layout">
    <div class="layout-header">

	<div class="layout-header-main">
		<div class="container">
			<div class="row justify-content-lg-center">
				<div class="col-12 col-lg-9">

					<div class="navbar">

						<div class="logo">
							<a href="https://yz0812.github.io">
								<img class="logo" src="https://yz0812.github.io/media/images/site_avatar.png?v=1770995982259"
									alt="">
							</a>
						</div>

						<div class="menu d-md-inline-block d-none">
							<ul class="layout-navigation-list">
								
								<li class="layout-navigation-item"><a title="归档"
										href="/archives">归档</a>
								</li>
								
								<li class="layout-navigation-item"><a title="标签"
										href="/tags">标签</a>
								</li>
								
								<li class="layout-navigation-item"><a title="关于"
										href="/post/about">关于</a>
								</li>
								
							</ul>
						</div>

						

						<div class="nav d-md-none d-inline-block">
							<div class="trigger">
								<i class="fa fa-bars layout-btn-toggle" aria-hidden="true"></i>
							</div>
						</div>

					</div>

				</div>
			</div>




		</div>
	</div>

</div>
    <div class="layout-collapse d-md-none">
	<div class="layout-collapse-main">
		<ul class="layout-collapse-list">
			
			<li class="layout-collapse-item"><a title="归档" href="/archives">归档</a></li>
			
			<li class="layout-collapse-item"><a title="标签" href="/tags">标签</a></li>
			
			<li class="layout-collapse-item"><a title="关于" href="/post/about">关于</a></li>
			

		</ul>
	</div>
</div>

    <div class="layout-content">
      <div class="layout-content-main">
        <div class="container">
          <div class="row justify-content-lg-center">
            <div class="col-12 col-lg-9">
              <div class="layout-post">
                <div class="layout-post-body">
                  <div class="row">

                    <div class="col-12 col-lg-10">
                      <div class="layout-post-main m-right m-md-right">
                        <div class="layout-post-header">
                          <h1 class="layout-post-title">VAVR 快速指南</h1>
                          <div class="layout-post-meta">
                            <div class="item">
                               <a href="https://yz0812.github.io/tag/EXPhuDLUo/" class="post--keyword"
                                data-title="教程" data-type="post_tag" data-term-id="39">教程</a>
                              
                            </div>
                            <div class="item">
                              <span>2022-08-18</span>
                            </div>
                          </div>
                        </div>
                        <div class="layout-post-content">
                          <div class="layout-post-item">
                            
                            <p class="with-img"><img src="https://fastly.jsdelivr.net/gh/yz0812/mypic@master/img/62.jpg"
                                class="attachment-full size-full wp-post-image" alt="VAVR 快速指南" /></p>
                            
                            <h2 id="vavr"><a href="https://docs.vavr.io/#_introduction">VAVR</a><a href="https://www.baeldung.com/vavr">使用合集</a></h2>
<h3 id="导入">导入</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.vavr&lt;/groupId&gt;
        &lt;artifactId&gt;vavr&lt;/artifactId&gt;
        &lt;version&gt;0.10.4&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="1元组">1.元组</h3>
<p>Java 中没有直接等效的元组数据结构。元组是<a href="https://www.baeldung.com/cs/functional-programming">函数式编程</a>语言中的一个常见概念。<strong>元组是不可变的，可以以类型安全的方式保存多个不同类型的对象。</strong></p>
<p>Vavr 将元组引入 Java 8。元组的类型为<em>Tuple1，Tuple2</em>到<em>Tuple8</em> ，具体取决于它们要采用的元素数量。</p>
<p>目前有八个元素的上限。我们访问像<em>元组**._n</em>这样的元组的元素，其中<em>n</em>类似于数组中索引的概念：</p>
<h4 id="11-映射元组组件">1.1 映射元组组件</h4>
<p>下面是一个如何创建一个包含 String 和 Integer 的元组的示例：</p>
<pre><code class="language-java">       Tuple2&lt;String, Integer&gt; java8 = Tuple.of(&quot;Java&quot;, 8);
        String s = java8._1;
        Integer i = java8._2;
</code></pre>
<ol>
<li>
<p>元组是通过静态工厂方法创建的<code>Tuple.of()</code></p>
</li>
<li>
<p>获取此元组的第一个元素。</p>
</li>
<li>
<p>获取此元组的第二个元素。</p>
</li>
</ol>
<h4 id="12-映射元组组件">1.2 映射元组组件</h4>
<p>也可以使用一个映射函数来映射一个元组。</p>
<pre><code class="language-java">Tuple2&lt;String, Integer&gt; that = java8.map(
        str -&gt; s.substring(2) + &quot;vr&quot;,
        integer -&gt; i / 8
);
</code></pre>
<h4 id="13-使用一个映射器映射一个元组">1.3 使用一个映射器映射一个元组</h4>
<p>Transform 根据元组的内容创建一个新类型。</p>
<pre><code class="language-java">String that = java8.apply(
        (s, i) -&gt; s.substring(2) + &quot;vr &quot; + i / 8
);
</code></pre>
<h3 id="2-功能接口">2.  功能接口</h3>
<p>随着 Java 8 的到来，<a href="https://www.baeldung.com/java-8-functional-interfaces">函数式接口</a>被内置并且更易于使用，尤其是与 lambdas 结合使用时。</p>
<p>但是，Java 8 只提供了两个基本功能。一个只接受一个参数并产生一个结果：</p>
<pre><code class="language-java">@Test
public void givenJava8Function_whenWorks_thenCorrect() {
    Function&lt;Integer, Integer&gt; square = (num) -&gt; num * num;
    int result = square.apply(2);

    assertEquals(4, result);
}
</code></pre>
<p>第二个只接受两个参数并产生结果：</p>
<pre><code class="language-java">@Test
public void givenJava8BiFunction_whenWorks_thenCorrect() {
    BiFunction&lt;Integer, Integer, Integer&gt; sum =
            (num1, num2) -&gt; num1 + num2;
    int result = sum.apply(5, 7);

    assertEquals(12, result);
}
</code></pre>
<p>另一方面，Vavr 进一步扩展了 Java 中函数式接口的概念，最多支持八个参数，并使用记忆、组合和柯里化的方法为 API 增添趣味。</p>
<p>就像元组一样，这些函数式接口是根据它们接受的参数数量来命名的：<em>Function0</em>、<em>Function1</em>、<em>Function2</em>等。使用 Vavr，我们可以这样编写上述两个函数：</p>
<pre><code class="language-java">@Test
public void givenVavrFunction_whenWorks_thenCorrect() {
    Function1&lt;Integer, Integer&gt; square = (num) -&gt; num * num;
    int result = square.apply(2);

    assertEquals(4, result);
}
</code></pre>
<p>和这个：</p>
<pre><code class="language-java">@Test
public void givenVavrBiFunction_whenWorks_thenCorrect() {
    Function2&lt;Integer, Integer, Integer&gt; sum = 
      (num1, num2) -&gt; num1 + num2;
    int result = sum.apply(5, 7);

    assertEquals(12, result);
}
</code></pre>
<p>当没有参数但我们仍然需要输出时，在 Java 8 中我们需要使用<em>Supplier</em>类型，在 Vavr <em>Function0</em>中可以提供帮助：</p>
<pre><code class="language-java">@Test
public void whenCreatesFunction_thenCorrect0() {
    Function0&lt;String&gt; getClazzName = () -&gt; this.getClass().getName();
    String clazzName = getClazzName.apply();

    assertEquals(&quot;com.baeldung.vavr.VavrTest&quot;, clazzName);
}
</code></pre>
<p>我们还可以将任何函数的静态工厂方法<em>FunctionN.of</em>结合起来，从方法引用中创建 Vavr 函数。就像我们有以下<em>sum</em>方法：</p>
<pre><code class="language-java">public int sum(int a, int b) {
    return a + b;
}
</code></pre>
<p>我们可以像这样创建一个函数：</p>
<pre><code class="language-java">@Test
public void whenCreatesFunctionFromMethodRef_thenCorrect() {
    Function2&lt;Integer, Integer, Integer&gt; sum = Function2.of(this::sum);
    int summed = sum.apply(5, 6);
    assertEquals(11, summed);
}
</code></pre>
<h3 id="3-option">3. Option</h3>
<p><em>Option 的主要目标是通过利用 Java 类型系统来消除我们代码中的空检查。</em></p>
<p><em>Option</em>是 Vavr 中的一个对象容器，其最终目标类似于Java 8 中的<a href="https://www.baeldung.com/java-optional">Optional。Vavr</a>的<em>Option</em>实现了*Serializable、Iterable，*并具有更丰富的 API <em>。</em></p>
<p>由于 Java 中的任何对象引用都可以具有<em>null</em>值，因此我们通常必须在使用<em>if</em>语句之前检查它是否为 null。这些检查使代码健壮和稳定：</p>
<pre><code>@Test
public void givenValue_whenCreatesOption_thenCorrect() {
    Option&lt;Object&gt; noneOption = Option.of(null);
    Option&lt;Object&gt; someOption = Option.of(&quot;val&quot;);

    assertEquals(&quot;None&quot;, noneOption.toString());
    assertEquals(&quot;Some(val)&quot;, someOption.toString());
}
</code></pre>
<h3 id="4-try">4. Try</h3>
<p>在 Vavr 中，<em><strong>Try*</strong> **是可能导致异常</em>***的计算容器。**</p>
<p>由于<em>Option</em>包装了一个可为空的对象，因此我们不必使用<em>if</em>检查显式处理<em>空值，而**Try</em>包装计算，因此我们不必使用<em>try-catch</em>块显式处理异常。</p>
<p>以下面的代码为例：</p>
<pre><code class="language-java">@Test(expected = ArithmeticException.class)
public void givenBadCode_whenThrowsException_thenCorrect() {
    int i = 1 / 0;
}
</code></pre>
<p>如果没有<em>try-catch</em>块，应用程序就会崩溃。为了避免这种情况，您需要将语句包装在<em>try-catch</em>块中。使用 Vavr，我们可以将相同的代码包装在<em>Try</em>实例中并获得结果：</p>
<pre><code class="language-java">@Test
public void givenBadCode_whenTryHandles_thenCorrect() {
    Try&lt;Integer&gt; result = Try.of(() -&gt; 1 / 0);

    assertTrue(result.isFailure());
}

// 在上面的代码片段中，我们选择简单地检查成功或失败。我们也可以选择返回一个默认值：
@Test
public void givenBadCode_whenTryHandles_thenCorrect2() {
    Try&lt;Integer&gt; computation = Try.of(() -&gt; 1 / 0);
    int errorSentinel = result.getOrElse(-1);

    assertEquals(-1, errorSentinel);
}
// 甚至明确抛出我们选择的异常：
@Test(expected = ArithmeticException.class)
public void givenBadCode_whenTryHandles_thenCorrect3() {
    Try&lt;Integer&gt; result = Try.of(() -&gt; 1 / 0);
    result.getOrElseThrow(ArithmeticException::new);
}
</code></pre>
<p>在上述所有情况下，我们都可以控制计算后发生的事情，这要归功于 Vavr 的<em>Try</em>。</p>
<p><strong>try...catch的一种实现方式</strong></p>
<pre><code class="language-java">/**
* 输出
*	 failure: / by zero
*  finally
*/
Try.of(() -&gt; 1 / 0)
  //正确执行
    .andThen(r -&gt; System.out.println(&quot;and then &quot; + r))
  //错误执行
    .onFailure(error -&gt; System.out.println(&quot;failure&quot; + error.getMessage()))
    .andFinally(() -&gt; {
      System.out.println(&quot;finally&quot;);
});
</code></pre>
<p><strong>recoverWith 方法，我们可以很优雅的实现降级策略</strong></p>
<pre><code class="language-java">/**
* 输出
* NPE
* IllegalState
* Unknown
*/
@Test
public void whenTry() {
    System.out.println(testTryWithRecover(new NullPointerException()));
    System.out.println(testTryWithRecover(new IllegalStateException()));
    System.out.println(testTryWithRecover(new RuntimeException()));
}

private String testTryWithRecover(Exception e) {
    return (String) Try.of(() -&gt; {
                throw e;
            })
            .recoverWith(NullPointerException.class, Try.of(() -&gt; &quot;NPE&quot;))
            .recoverWith(IllegalStateException.class, Try.of(() -&gt; &quot;IllegalState&quot;))
            .recoverWith(RuntimeException.class, Try.of(() -&gt; &quot;Unknown&quot;))
            .get();
}
</code></pre>
<p><strong>使用 map 对结果进行转换，并且与 Option 进行交互</strong></p>
<pre><code class="language-java">@Test
public void testTryMap() {
    String res = Try.of(() -&gt; &quot;hello world&quot;)
            .map(String::toUpperCase)
            .toOption()
            .getOrElse(() -&gt; &quot;default&quot;);
    System.out.println(res);
}
</code></pre>
<h3 id="5-lazy">5. Lazy</h3>
<p><em>Lazy</em>是一个容器，它表示一个延迟计算的值，即延迟计算直到需要结果。此外，评估值被缓存或记忆，并在每次需要时一次又一次地返回，而无需重复计算：</p>
<pre><code class="language-java">@Test
public void givenFunction_whenEvaluatesWithLazy_thenCorrect() {
    Lazy&lt;Double&gt; lazy = Lazy.of(Math::random);
    //检查是否评估了此惰性值 通过调用get()  如果该值被评估，则为 true，否则为 false。
    assertFalse(lazy.isEvaluated());

    double val1 = lazy.get();
    assertTrue(lazy.isEvaluated());

    double val2 = lazy.get();
    assertEquals(val1, val2, 0.1);
}
</code></pre>
<p>在上面的示例中，我们使用的函数是<code>Math.random</code>。在第二行中，我们使用了<code>isEvaluated</code>检查了该值并意识到该函数尚未执行。</p>
<p>在第三行代码中，我们通过调用<code>Lazy.get</code>来计算出该值。此时，函数执行并且<code>Lazy.evaluate</code>返回 true。</p>
<p>我们再次获取来确认*Lazy的记忆位。*如果我们提供的函数再次执行，我们肯定会收到一个不同的随机数。</p>
<p>然而，当最终断言确认时， <em>Lazy</em>再次延迟返回最初计算相同的值。</p>
<h3 id="6-模式匹配">6. 模式匹配</h3>
<p>模式匹配是几乎所有函数式编程语言中的原生概念。目前Java中没有这样的东西。</p>
<p>相反，每当我们想要根据收到的输入执行计算或返回值时，我们使用多个<em>if</em>语句来解析要执行的正确代码：</p>
<pre><code class="language-java">@Test
public void whenIfWorksAsMatcher_thenCorrect() {
    int input = 3;
    String output;
    if (input == 0) {
        output = &quot;zero&quot;;
    }
    if (input == 1) {
        output = &quot;one&quot;;
    }
    if (input == 2) {
        output = &quot;two&quot;;
    }
    if (input == 3) {
        output = &quot;three&quot;;
    }
    else {
        output = &quot;unknown&quot;;
    }

    assertEquals(&quot;three&quot;, output);
}
</code></pre>
<p>我们可以突然看到代码跨越多行，同时只检查三个案例。每项检查占用三行代码。如果我们必须检查多达一百个案例，那将是大约 300 行，不好！</p>
<p>另一种选择是使用<em>switch</em>语句：</p>
<pre><code class="language-java">@Test
public void whenSwitchWorksAsMatcher_thenCorrect() {
    int input = 2;
    String output;
    switch (input) {
    case 0:
        output = &quot;zero&quot;;
        break;
    case 1:
        output = &quot;one&quot;;
        break;
    case 2:
        output = &quot;two&quot;;
        break;
    case 3:
        output = &quot;three&quot;;
        break;
    default:
        output = &quot;unknown&quot;;
        break;
    }

    assertEquals(&quot;two&quot;, output);
}
</code></pre>
<p>没有更好的。我们仍然平均每次检查 3 行。很多混乱和潜在的错误。忘记<em>break</em>子句在编译时不是问题，但可能会导致以后难以检测到错误。<br>
<em>最后，像$()<em>这样的原子模式替换了然后评估表达式或值的条件。我们还将它作为第二个参数提供给</em>Case</em>：</p>
<pre><code class="language-java">@Test
public void whenMatchworks_thenCorrect() {
    int input = 2;
    String output = Match(input).of(
      Case($(1), &quot;one&quot;), 
      Case($(2), &quot;two&quot;), 
      Case($(3), &quot;three&quot;),
      Case($(), &quot;?&quot;));
 
    assertEquals(&quot;two&quot;, output);
}
</code></pre>
<p>例如，我们可以用谓词替换原子表达式。想象一下，我们正在解析一个控制台命令以获取<em>帮助</em>和<em>版本</em>标志：一些用户可能更熟悉简写版本 (-v)，而另一些用户则更熟悉完整版本 (-version)。一个好的设计师必须考虑所有这些情况。</p>
<p>不需要多个<em>if</em>语句，我们已经处理了多个条件。</p>
<pre><code class="language-java">@Test
public void whenMatchworks_thenCorrect() {
    String arg=&quot;--help&quot;;
    Match(arg).of(
            Case($  (isIn(&quot;-h&quot;, &quot;--help&quot;)), o -&gt; run(this::displayHelp)),
            Case($(isIn(&quot;-v&quot;, &quot;--version&quot;)), o -&gt; run(this::displayVersion)),
            Case($(), o -&gt; run(() -&gt; {
                throw new IllegalArgumentException(arg);
            }))
    );
}
private void displayVersion(){
    System.out.println(&quot;--version&quot;);
}

private void displayHelp(){
    System.out.println(&quot;--help&quot;);
}
</code></pre>
<h4 id="61-穷举">6.1 穷举</h4>
<p>最后一个通配符模式<code>$()</code>使我们免于大小写不匹配时抛出的 MatchError。</p>
<p>因为我们不能像 Scala 编译器那样执行详尽检查，所以我们提供了返回可选结果的可能性：</p>
<pre><code class="language-java">Integer i = 3;
Option&lt;String&gt; s = Match(i).option(
        Case($(0), &quot;zero&quot;)
);
System.out.println(s.isEmpty());
</code></pre>
<h4 id="62-句法糖">6.2 句法糖</h4>
<pre><code class="language-java">import static io.vavr.Predicates.*;

//is用来来测试一个对象是否等于指定的value ，使用Objects.equals(Object, Object)进
String str = Match(i).of(
         Case($(is(1)), &quot;one&quot;),
         Case($(is(2)), &quot;two&quot;),
         Case($(), &quot;?&quot;)
);
System.out.println(str);
//使用isIn谓词来检查多个条件
Match(arg).of(
    Case($(isIn(&quot;-h&quot;, &quot;--help&quot;)), o -&gt; run(this::displayHelp)),
    Case($(isIn(&quot;-v&quot;, &quot;--version&quot;)), o -&gt; run(this::displayVersion)),
    Case($(), o -&gt; run(() -&gt; {
        throw new IllegalArgumentException(arg);
    }))
);
</code></pre>
<h4 id="63-类型匹配">6.3 类型匹配</h4>
<pre><code class="language-java">Object obj = 1.1;
Number plusOne = Match(obj).of(
        Case($(instanceOf(Integer.class)), i -&gt; i + 1),
        Case($(instanceOf(Double.class)), d -&gt; d + 2),
        Case($(), o -&gt; {
            throw new NumberFormatException();
        })
);
</code></pre>
<h4 id="64-try">6.4 Try</h4>
<p>对于许多 Vavr 类型，已经存在匹配模式。它们通过以下方式导入</p>
<pre><code class="language-java">import static io.vavr.Patterns.*;
</code></pre>
<ul>
<li>Success：代表执行没有异常</li>
<li>Failure：代表执行出现异常</li>
</ul>
<pre><code class="language-java">var res = Try.of(() -&gt; &quot;Nice&quot;);
String of = Match(res).of(
        // 匹配任意成功的情况
        Case($Success($()), r -&gt; &quot;Nice&quot;),
        // 匹配任意失败的情况
        Case($Failure($()), r -&gt; &quot;fail&quot;)
);
System.out.println(of);
</code></pre>
<pre><code class="language-java">var res = Try.of(() -&gt; {
    throw new RuntimeException();
});
Object of = Match(res).of(
        // 匹配成功情况
        Case($Success($()), r -&gt; run(Assert::fail)),
        // 匹配异常为 RuntimeException
        Case($Failure($(instanceOf(RuntimeException.class))), r -&gt; true),
        // 匹配异常为 IllegalStateException
        Case($Failure($(instanceOf(IllegalStateException.class))), r -&gt; run(Assert::fail)),
        // 匹配异常为 NullPointerException
        Case($Failure($(instanceOf(NullPointerException.class))), r -&gt; run(Assert::fail)),
        // 匹配其余失败的情况
        Case($Failure($()), r -&gt; run(Assert::fail))
);
System.out.println(of);
</code></pre>
<h4 id="65-option">6.5 Option</h4>
<ul>
<li>Some: 代表有值</li>
<li>None: 代表没有值</li>
</ul>
<pre><code class="language-java">import static io.vavr.Patterns.*;

Option option = Option.of(&quot;defined&quot;);
String of = Match(option).of(
        Case($Some($()), &quot;defined&quot;),
        Case($None(), &quot;empty&quot;)
);
System.out.println(of);
</code></pre>
<h4 id="66-tuple">6.6 Tuple</h4>
<pre><code class="language-java">var tup = Tuple.of(&quot;hello&quot;, 2);
// 模式匹配
Match(tup).of(
        Case($Tuple2($(is(&quot;hello&quot;)), $(is(1))), (t1, t2) -&gt; run(() -&gt; {
            System.out.println(true);
        })),
        Case($Tuple2($(), $()), (t1, t2) -&gt; run(() -&gt; {
            System.out.println(false);
        }))
);
</code></pre>
<h4 id="67-isnull">6.7 isNull</h4>
<pre><code class="language-java">@Test
public void givenInput_whenMatchesNull_thenCorrect() {
    Object obj=5;
    String s = Match(obj).of(
      Case($(isNull()), &quot;no value&quot;), 
      Case($(isNotNull()), &quot;value found&quot;));

    assertEquals(&quot;value found&quot;, s);
}
</code></pre>
<h4 id="68-allof">6.8 allOf</h4>
<p>可以使用allOf谓词进行AND运算</p>
<pre><code class="language-java">    @Test
    public void givenInput_whenMatchAllWorks_thenCorrect() {
        Integer i = null;
        String s = Match(i).of(
                // 不等于空，并且匹配isIn中的值 相当于 and &amp;&amp;
                Case($(allOf(isNotNull(),isIn(1,2,3,null))), &quot;Number found&quot;),
                Case($(), &quot;Not found&quot;));
        assertEquals(&quot;Not found&quot;, s);
    }
</code></pre>
<h4 id="69-anyof">6.9 anyOf</h4>
<p>可以使用<em>anyOf</em>谓词进行 OR 运算</p>
<blockquote>
<p>假设我们按出生年份筛选候选人，我们只需要出生于 1990、1991 或 1992 年的候选人。</p>
<p>如果没有找到这样的候选人，那么我们只能接受 1986 年出生的人</p>
</blockquote>
<pre><code class="language-java">@Test
    public void givenInput_whenMatchesAnyOfWorks_thenCorrect() {
        Integer year = 1990;
        String s = Match(year).of(
          Case($(anyOf(isIn(1990, 1991, 1992), is(1986))), &quot;Age match&quot;), 
          Case($(), &quot;No age match&quot;));
        assertEquals(&quot;Age match&quot;, s);
    }
</code></pre>
<h4 id="610-noneof">6.10 noneOf</h4>
<p>可以使用<em>noneOf</em>谓词进行 != 运算</p>
<pre><code class="language-java">    @Test
    public void givenInput_whenMatchesNoneOfWorks_thenCorrect() {
        Integer year = 1990;
        String s = Match(year).of(
                Case($(noneOf(isIn(1990, 1991, 1992), is(1986))), &quot;Age match&quot;),
                Case($(), &quot;No age match&quot;));
        assertEquals(&quot;No age match&quot;, s);
    }
</code></pre>
<h4 id="611-自定义谓词">6.11 自定义谓词</h4>
<p>有了 lambdas 的知识，我们可以构建和使用我们自己的谓词，甚至直接将它们写成内联。</p>
<pre><code class="language-java">    @Test
    public void whenMatchWorksWithCustomPredicate_thenCorrect() {
        int i = 3;
        String s = Match(i).of(
                Case($(n -&gt; n == 1), &quot;one&quot;),
                Case($(n -&gt; n == 2), &quot;two&quot;),
                Case($(n -&gt; n == 3), &quot;three&quot;),
                Case($(), &quot;?&quot;));
        assertEquals(&quot;three&quot;, s);
    }
</code></pre>
<p>如果我们需要更多参数，我们还可以应用功能接口代替谓词。contains 示例可以像这样重写，虽然有点冗长，但它让我们对谓词的作用有更大的权力：</p>
<pre><code class="language-java">    @Test
    public void givenInput_whenContainsWorks_thenCorrect2() {
        int i = 5;
        BiFunction&lt;Integer, List&lt;Integer&gt;, Boolean&gt; contains = (t, u) -&gt; u.contains(t);
        String s = Match(i).of(
                Case($(o -&gt; contains.apply(i, Arrays.asList(2, 4, 6, 8))), &quot;Even Single Digit&quot;),
                Case($(o -&gt; contains.apply(i, Arrays.asList(1, 3, 5, 7, 9))), &quot;Odd Single Digit&quot;),
                Case($(), &quot;Out of range&quot;));
        assertEquals(&quot;Odd Single Digit&quot;, s);
    }
</code></pre>
<p>在上面的示例中，我们创建了一个 Java 8 <em>BiFunction</em>，它只检查两个参数之间的<em>isIn</em>关系。</p>
<p>也可以为此使用 Vavr 的<strong>FunctionN</strong>.因此，如果内置谓词与您的要求不完全匹配，或者您希望控制整个评估，则使用自定义谓词。</p>
<h3 id="7-either">7. Either</h3>
<p><code>Either</code> 表示可能有两种不同类型的值，分别称为左值或右值。只能是其中的一种情况。<code>Either</code> 通常用来表示成功或失败两种情况。惯例是把成功的值作为右值，而失败的值作为左值。可以在 <code>Either</code> 上添加应用于左值或右值的计算。应用于右值的计算只有在 <code>Either</code> 包含右值时才生效，对左值也是同理。</p>
<pre><code class="language-java">@Test  
public void whenEither_thenCorrect(String[] args) {
        Either&lt;String, String&gt; either = compute()
                .map(str -&gt; str + &quot; World&quot;)
                .mapLeft(Throwable::getMessage);
        System.out.println(either);
    }

    private static Either&lt;Throwable, String&gt; compute() {
        ThreadLocalRandom random =
                ThreadLocalRandom.current();
        return random.nextBoolean()? Either.left(new RuntimeException(&quot;Boom!&quot;)): Either.right(&quot;Hello&quot;);
    }
</code></pre>
<h3 id="8-future">8. Future</h3>
<p>Future 是在某个时刻可用的计算结果。提供的所有操作都是非阻塞的。底层 ExecutorService 用于执行异步处理程序</p>
<p>Vavr通过Future简化了线程的使用方式，不用再像Java定义任务，创建线程，再执行，直接创建一个Future对象即可。Future提供的所有操作都是非阻塞的，其底层的ExecutorService用于执行异步处理程序。代码如下：</p>
<pre><code class="language-java">    @Test
    public void testFuture() {
        System.out.println(&quot;当前线程名称：&quot; + Thread.currentThread().getName());
        Integer result = Future.of(() -&gt; {
                    System.out.println(&quot;future线程名称：&quot; + Thread.currentThread().getName());
                    Thread.sleep(2000);
                    return 100;
                })
                .map(i -&gt; i * 10)
                .await()
                .get();
        System.out.println(result);
    }

//        这个 Future 可不是 java.util.concurrent.Future，但它们都是对异步计算结果的一个抽象。
//        vavr 的 Future 提供了比 java.util.concurrent.Future 更友好的回调机制
//
//        onFailure 失败的回调
//        onSuccess 成功的回调
@Test
public void testFutureFailure() {
    final var word = &quot;hello world&quot;;
    io.vavr.concurrent.Future
      .of(Executors.newFixedThreadPool(1), () -&gt; word)
      .onFailure(throwable -&gt; Assert.fail(&quot;不应该走到 failure 分支&quot;))
      .onSuccess(result -&gt; Assert.assertEquals(word, result));
}

@Test
public void testFutureSuccess() {
    io.vavr.concurrent.Future
      .of(Executors.newFixedThreadPool(1), () -&gt; {
          throw new RuntimeException();
      })
      .onFailure(throwable -&gt; Assert.assertTrue(throwable instanceof RuntimeException))
      .onSuccess(result -&gt; Assert.fail(&quot;不应该走到 success 分支&quot;));
}


</code></pre>
<h3 id="9-list">9. List</h3>
<p>Vavr 团队在设计满足函数式编程要求（即持久性、不变性）的新集合 API 方面付出了很多努力。 Java 集合是可变的，使它们成为程序失败的重要来源，尤其是在存在并发的情况下。 Collection 接口提供如下方法：</p>
<pre><code class="language-java">interface Collection&lt;E&gt; {
    void clear();
}
</code></pre>
<p>此方法删除集合中的所有元素（产生副作用）并且不返回任何内容。创建了诸如<em>ConcurrentHashMap</em>之类的类来处理已经创建的问题。</p>
<p>这样的类不仅增加了零边际收益，而且降低了它试图填补漏洞的类的性能。</p>
<p><strong>通过不变性，我们可以免费获得线程安全</strong>：无需编写新类来处理原本不应该存在的问题。</p>
<p>在 Java 中为集合添加不变性的其他现有策略仍然会产生更多问题，即异常：</p>
<pre><code class="language-java">@Test(expected = UnsupportedOperationException.class)
public void whenImmutableCollectionThrows_thenCorrect() {
    java.util.List&lt;String&gt; wordList = Arrays.asList(&quot;abracadabra&quot;);
    java.util.List&lt;String&gt; list = Collections.unmodifiableList(wordList);
    list.add(&quot;boom&quot;);
}
</code></pre>
<p>以上所有问题在 Vavr 集合中都不存在。</p>
<p>在 Vavr 中创建列表：</p>
<pre><code class="language-java">@Test
public void whenCreatesVavrList_thenCorrect() {
    List&lt;Integer&gt; intList = List.of(1, 2, 3);

    assertEquals(3, intList.length());
    assertEquals(new Integer(1), intList.get(0));
    assertEquals(new Integer(2), intList.get(1));
    assertEquals(new Integer(3), intList.get(2));
}

@Test
public void whenSumsVavrList_thenCorrect() {
    int sum = List.of(1, 2, 3).sum().intValue();

    assertEquals(6, sum);
}
</code></pre>
<h3 id="10-处理stream异常">10. 处理stream异常</h3>
<h4 id="101简介">10.1.简介</h4>
<p><strong>JDK 提供的功能接口没有处理异常的能力</strong></p>
<p>下面我们用代码实践，<strong>定义一个抛出异常方法</strong><code>readFromFile</code></p>
<pre><code class="language-java">    static Integer readFromFile(Integer integer) throws IOException {
        if (integer % 2 == 0) {
            throw new IllegalStateException(&quot;an integer is not even&quot;);
        }
        // logic to read from file which throws IOException
        return integer;
    }
</code></pre>
<p><strong>消费这个方法</strong>可以看到我们必须要使用<code>try-catch</code>包装这个方法</p>
<pre><code class="language-java">    @Test
    public void streams() {
        List&lt;Integer&gt; integers = Arrays.asList(3, 9, 7, 0, 10, 20);
        integers.stream().map(i -&gt; {
            try {
                return readFromFile(i);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
    }
</code></pre>
<h4 id="102使用checkedfunction">10.2.使用CheckedFunction</h4>
<p>Vavr 提供了<em>函数式接口</em>，这些接口具有抛出检查异常的函数。这些函数是<code>CheckedFunction0</code>、<code>CheckedFunction1</code>等等，直到<code>CheckedFunction8</code>函数名末尾的0 <em>, 1, ... 8表示函数的输入参数个数。</em></p>
<pre><code class="language-java">    @Test
    public void checkedFunction() {
        List&lt;Integer&gt; integers = Arrays.asList(3, 9, 7, 0, 10, 20);
        CheckedFunction1&lt;Integer, Integer&gt; readFunction = i -&gt; readFromFile(i);
        integers.stream().map(readFunction.unchecked()).forEach(i -&gt; System.out.println(i));
   }

   // 输出 java.lang.IllegalStateException: an integer is not even
</code></pre>
<p>如你所见，没有使用<code>try-catch</code>包装方法,我们仍然可以在 lambda 表达式中调用异常抛出方法，<em>在使用Stream</em> API的这个特性时我们必须小心，<span style="color:red">因为异常会立即终止操作——放弃流的其余部分</span>。</p>
<h4 id="103使用api方法">10.3.使用API方法</h4>
<p>与2效果一样，<span style="color:red">出现异常会立即终止操作</span></p>
<pre><code class="language-java">    @Test
    public void api() {
        List&lt;Integer&gt; integers = Arrays.asList(3, 9, 7, 0, 10, 20);
        integers.stream().map(API.unchecked(i -&gt; readFromFile(i))).forEach(i -&gt; System.out.println(i));
    }

    // 输出 java.lang.IllegalStateException: an integer is not even
</code></pre>
<h4 id="104使用lift">10.4.使用lift</h4>
<p>为了优雅地处理<em>IOException</em> ，我们可以在 lambda 表达式中引入标准的 try-catch块。但是，lambda 表达式的简洁性将会丢失。Vavr 的lift救了我们。</p>
<pre><code class="language-java">    @Test
    public void lift() {
        List&lt;Integer&gt; integers = Arrays.asList(3, 9, 7, 0, 10, 20);
        //CheckedFunction1.lift返回的是  Option&lt;R&gt;类型的值，所以可以用getOrElse来为异常方法设定默认值
        integers.stream().map(CheckedFunction1.lift(i -&gt; readFromFile(i))).map(k -&gt; k.getOrElse(-1)).forEach(i -&gt; System.out.println(i));
    }
</code></pre>
<p>输出</p>
<pre><code class="language-log">3
9
7
-1
-1
-1
</code></pre>
<h4 id="105使用try">10.5.使用Try</h4>
<p>虽然上一节中的方法<em>lift()<em>解决了程序突然终止的问题，但它实际上吞下了异常。因此，我们方法的使用者不知道是什么导致了默认值。另一种方法是使用</em>Try</em>容器。<em>Try</em>是一个特殊的容器，我们可以用它来封装一个可能引发异常的操作。在这种情况下，生成的<em>Try</em>对象代表一个<em>失败</em>，它包装了异常。</p>
<p>让我们看一下使用<em>Try</em>的代码：</p>
<pre><code class="language-java">    @Test
    public void trys() {
        List&lt;Integer&gt; integers = Arrays.asList(3, 9, 7, 0, 10, 20);
        //CheckedFunction1.liftTry返回的是  Try&lt;R&gt;类型的值 使用Value.toJavaStream将结果转成流
        integers.stream().map(CheckedFunction1.liftTry(i -&gt; readFromFile(i))).flatMap(Value::toJavaStream).forEach(i -&gt; System.out.println(i));
        //输出 3 9 7

        //通过Try.isFailure方法筛选出异常值，打印异常信息
        integers.stream().map(CheckedFunction1.liftTry(i -&gt; readFromFile(i))).filter(Try::isFailure).forEach(i -&gt; System.out.println(i.getCause()));
    }
</code></pre>

                          </div>
                        </div>
                        <div class="layout-post-social">
                          <div class="item reader">
                            <div id="/post/vavr/" class="leancloud-visitors view"
                              data-flag-title="VAVR 快速指南">
                              <span class="post-meta-item-text">阅读 </span>
                              <span class="leancloud-visitors-count"></span>
                            </div>
                          </div>
                        </div>

                        <div class="layout-post-navigation">
                          <div class="navigation-list">
                            
                            <div class="post-card row">
                              
                              <div class="card-content col-8 col-md-9">
                                <div class="card-body">
                                  <div class="header">
                                    <a href="https://yz0812.github.io/post/docker-xue-xi-zi-liao/" class="title">
                                      <h4> Docker 学习资料</h4>
                                    </a>
                                  </div>
                                  <div class="inner d-none d-sm-block">
                                    <div class="abstract">
                                      
                                    </div>
                                  </div>
                                </div>
                                <div class="card-footer">
                                  <div class="item"><span>上一篇</span></div>
                                  <div class="item">2022-08-20</div>
                                </div>
                              </div>
                              <div class="card-thumb col-4 col-md-3">
                                <div class="thumb">
                                  <a href="https://yz0812.github.io/post/docker-xue-xi-zi-liao/"
                                    style="background-image: url('https://fastly.jsdelivr.net/gh/yz0812/mypic@master/img/63.jpg');"></a>
                                </div>
                              </div>
                              
                            </div>

                            <div class="post-card row">
                              
                              <div class="card-content col-8 col-md-9">
                                <div class="card-body">
                                  <div class="header">
                                    <a href="https://yz0812.github.io/post/fan-hui-jie-guo-feng-zhuang-lei/" class="title">
                                      <h4>返回结果封装类</h4>
                                    </a>
                                  </div>
                                  <div class="inner d-none d-sm-block">
                                    <div class="abstract">
                                      
                                    </div>
                                  </div>
                                </div>
                                <div class="card-footer">
                                  <div class="item"><span>下一篇</span></div>
                                  <div class="item">2022-07-10</div>
                                </div>
                              </div>
                              <div class="card-thumb col-4 col-md-3">
                                <div class="thumb">
                                  <a href="https://yz0812.github.io/post/fan-hui-jie-guo-feng-zhuang-lei/"
                                    style="background-image: url('https://fastly.jsdelivr.net/gh/yz0812/mypic@master/img/61.jpg');"></a>
                                </div>
                              </div>
                              
                            </div>

                            
                          </div>
                        </div>

                        <div class="layout-comments" id="comments">
                          
                            
                        </div>
                      </div>
                    </div>

                    <div class="col-12 col-lg-2 d-none d-lg-block">
                      <div class="layout-post-sidebar">
                        <div class="layout-sidebar-item">
                          <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#vavr">VAVR</a>
<ul>
<li><a href="#%E5%AF%BC%E5%85%A5">导入</a></li>
<li><a href="#1%E5%85%83%E7%BB%84">1.元组</a>
<ul>
<li><a href="#11-%E6%98%A0%E5%B0%84%E5%85%83%E7%BB%84%E7%BB%84%E4%BB%B6">1.1 映射元组组件</a></li>
<li><a href="#12-%E6%98%A0%E5%B0%84%E5%85%83%E7%BB%84%E7%BB%84%E4%BB%B6">1.2 映射元组组件</a></li>
<li><a href="#13-%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%98%A0%E5%B0%84%E5%99%A8%E6%98%A0%E5%B0%84%E4%B8%80%E4%B8%AA%E5%85%83%E7%BB%84">1.3 使用一个映射器映射一个元组</a></li>
</ul>
</li>
<li><a href="#2-%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3">2.  功能接口</a></li>
<li><a href="#3-option">3. Option</a></li>
<li><a href="#4-try">4. Try</a></li>
<li><a href="#5-lazy">5. Lazy</a></li>
<li><a href="#6-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">6. 模式匹配</a>
<ul>
<li><a href="#61-%E7%A9%B7%E4%B8%BE">6.1 穷举</a></li>
<li><a href="#62-%E5%8F%A5%E6%B3%95%E7%B3%96">6.2 句法糖</a></li>
<li><a href="#63-%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D">6.3 类型匹配</a></li>
<li><a href="#64-try">6.4 Try</a></li>
<li><a href="#65-option">6.5 Option</a></li>
<li><a href="#66-tuple">6.6 Tuple</a></li>
<li><a href="#67-isnull">6.7 isNull</a></li>
<li><a href="#68-allof">6.8 allOf</a></li>
<li><a href="#69-anyof">6.9 anyOf</a></li>
<li><a href="#610-noneof">6.10 noneOf</a></li>
<li><a href="#611-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B0%93%E8%AF%8D">6.11 自定义谓词</a></li>
</ul>
</li>
<li><a href="#7-either">7. Either</a></li>
<li><a href="#8-future">8. Future</a></li>
<li><a href="#9-list">9. List</a></li>
<li><a href="#10-%E5%A4%84%E7%90%86stream%E5%BC%82%E5%B8%B8">10. 处理stream异常</a>
<ul>
<li><a href="#101%E7%AE%80%E4%BB%8B">10.1.简介</a></li>
<li><a href="#102%E4%BD%BF%E7%94%A8checkedfunction">10.2.使用CheckedFunction</a></li>
<li><a href="#103%E4%BD%BF%E7%94%A8api%E6%96%B9%E6%B3%95">10.3.使用API方法</a></li>
<li><a href="#104%E4%BD%BF%E7%94%A8lift">10.4.使用lift</a></li>
<li><a href="#105%E4%BD%BF%E7%94%A8try">10.5.使用Try</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="layout-totop d-none"><i class="fa fa-angle-up" aria-hidden="true"></i></div>

    	<div class="layout-footer">

		<div class="container">
			<div class="row justify-content-lg-center">
				<div class="col-12 col-lg-9">
					<div class="footer">
						<div class="row">
							<div class="col-12 col-md-9">
								<div class="footer-copy">
									
									<span>© 2018-05-01 </span>
									<a href="https://yz0812.github.io" title="yz">yz</a>
									<span class="px-2">⋅</span>
									
									
									<div class="footer-icp d-none d-sm-inline-block">
										<span class="px-2">⋅</span>
										
									</div>
								</div>
							</div>
							<div class="col-sm-3 d-none d-md-block">
								<div class="footer-links">
									
									
									
									
									
									
									
									
									
									
									
									
									
									
									
									
									
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>
		</div>

	</div>

	<script type="text/javascript" src='https://yz0812.github.io/media/scripts/main.js'></script>
	
	<script>
		var _hmt = _hmt || [];
		(function () {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?1bcfcef443c3da9720b8bc3f63856c73";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
	

  </div>
</body>

</html>